### lvaue & rvalue
C++11 之前分为左值和右值两种
C++11 之后分为左值（lvalue)，将亡值(xvalue)，纯右值(pvalue)，以及两种混合级别泛左值（glvalue）和右值（rvalue)五种。
具名(identity)：可以确定表达式与另一表达式是否指代同一实体，例如通过比较标识对象地址
可被移动：移动构造函数，移动赋值语句能够绑定于这个表达式

lvaue: 具名且不可被移动
xvalue: 具名且可被移动
pvalue: 不具名且可被移动
gvalue: 具名, lvalue和xvalue都属于gvalue
rvalue: 可被移动的表达式，pvalue和xvalue都属于rvalue

#### Part1 左值
可以将左值看成关联了名称的内存的位置，允许内存其他部分来访问它。
```
T& fun();
fun();
++a; // T& operator--()
--a; // T& operator++()
"ab";// &("abc")
```

#### Part2 纯右值
字面值或者函数返回的非引用值都是纯右值
```
a++; // const T operator++(int);
a--; // const T operator--(int);
T fun();
fun();

```

#### Part3 将亡值
可以理解成通过“盗取”其他变量的内存空间的方式获取的值。在确保其他变量不在被使用，或者即将销毁时，通过”盗取“的方式避免内存空间的分配和释放，能够延长变量的生命期。（通过右值引用来续命）
xvalue只能通过两种方式获取，这两种方式都涉及将一个左值赋给一个右值引用。
- 返回引用的函数的调用表达式， 如`static_cast<T&&>(t);` 该表达式得到一个xvalue
- 转换为右值引用的转换函数的调用表达式，如: `std::move(t)`

```
std::string fun() {
	std::string str;
	return str;
}

std::string sr = fun();
```
无论是C++11之前的拷贝还是C++11之后的move，str都要被销毁，所以称为将亡值

#### 引用
C++11之前分为左值引用和常量左值引用，C++11之后引入右值引用，所以目前包含三种引用：
-	常量左值引用：可以引用左值和右值
-	左值引用：可以引用左值
-	右值引用：可以引用右值

```
const int& a = 10; // OK
int &b = 10; 			 // ERROR
```
C++11中引入了右值引用，因为右值的生命周期很短，右值引用的引入，使得可以延长右值的生命周期。右值引用的作用是绑定右值。

```
int a = 1;
int &&rrb = a; //ERROR
int &&rrb = 1; //OK
```
右值引用本身是一个左值，因为能够取地址。表达式有两种属性，分别为类型和值类别，左值引用和右值引用属于类型，而左值和右值属于值类别。

#### 深入探究

右值引用有办法指向左值吗？
```
int a = 5;
int &ref_a_left = a;
int &&ref_a_right = std::move(a);
```
通常理解成将左值a通过`std::move`函数移动到右值ref_a_right中，实际上`std::move`是一个非常具有迷惑性的函数，它移动不了什么，唯一的功能是将左值强制转化成一个右值，等价于`static_cast<T&&>(lvalue)`

同样右值引用能指向右值？本质上是通过把右值提升为一个左值，然后通过std::move指向该左值。
```
int && ref_a = 5;
ref_a = 6;
		||
		\/
int temp = 5;
int &&ref_a = std::move(temp);
ref_a = 6;
```
问题：std::move返回的int&& 是左值还是右值？但是ref_a必须指向右值，所以右值引用既可以是左值又可以是右值（或者说作为返回值的&&是右值，作为声明出来的&&是左值）。

总结：1) 从性能上讲左右值引用没有本质区别，传参使用左右值引用都可以避免拷贝。
2) 右值引用可以直接指向右值，也可以通过std::move指向左值。而左值引用只能指向左值。
3) 作为函数形参时，右值引用更加灵活。

可移动对象在"需要拷贝且拷贝之后不在需要”的场景可以使用`std::move`触发移动语义。

#### std::forward
`std::move`只能转发出右值，而forward都可以
>	std::forward<T>(u)有两个参数，当T为左值引用类型时，u将被转发成T类型的左值；否则u将被转换成T类型的右值

